








# 프로젝트 소개
### 프로젝트 소개
본 프로젝트는 농산물 x-ray 이미지에서 결함을 검출할 수 있도록 시각화하는 프로젝트이다.  


![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/702b7a39-e77e-4a33-aea6-024a07769112)


<br><br>


### 프로젝트 배경
실제 농산물을 재배하는 환경에서 컨베이어 벨트 위의 농산물들의 결함을 실시간으로 검출할 수 있도록 도와준다.  


![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/c265a7d6-939f-44be-9528-8663468df7f3)


<br><br>


### 프로젝트 설계
본 프로젝트는 GUI 형태의 프로그램을 제공하며 아래와 같이 동작한다.  
- <b>Open 버튼</b>을 누르면 파일 탐색기가 열리며 이미지 파일을 여러 개 선택할 수 있다.  
- 이미지 파일을 선택하고 <b>detect 버튼</b>을 누르면 오른쪽에 결함 검출 알고리즘을 적용한 이미지가 나타난다.  
- 화면 아래의 인디케이터에 현재 몇 번째 이미지를 보고 있는지가 뜨며 (키보드) `A`키와 `D`키로 페이지를 이동할 수 있다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/67e7575b-f30f-49ae-b1c0-4f7815bd4aa6)

<br><br>

### 프로젝트 과정
- 추후에 추가할 예정



<br><br><br>

# 이미지 데이터 설명
농산물은 총 6가지 존재하고, 정상과 비정상으로 구별할 수 있으므로 모든 데이터는 12가지로 카테고리화할 수 있다.  
(농산물 = {`바나나`, `당근`, `양파`, `귤`, `피망`, `고구마`})  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/953d5762-7a15-4258-94b0-3ce6213d3ab7)

<br><br>

농산물 데이터의 이미지 크기는 `800 x 1024`, `400 x 1024` 두 가지 형태만 존재한다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/0c4122c4-9521-46b7-8055-8c83303c0934)

<br><br>

x-ray 이미지 데이터는 명암 영상으로 각 픽셀은 `0~255` 값을 가지며 밀도가 높을수록(검은색에 가까울수록) 픽셀 값이 작다.  

<br><br><br>


# 결함에 대한 정의
본 프로젝트에서 결함이란 `벌레가 파먹은 부분`, `썩은 부분`, `과일의 긁힌 자국` 등으로 정의한다.  
이러한 결함은 눈으로 봤을 때 x-ray 이미지 상에서 밀도가 낮게 보이는 특징이 있다.  

<br><br><br>

# 이미지 분석
이미지에서 찾을 수 있는 결함의 가장 큰 특징은 밀도가 다른 부분에 비해서 낮다는 특징이다.  
따라서, 밀도가 낮은 부분을 어떻게 하면 극대화할 수 있을까에 초점을 맞추며 이미지 분석을 진행했다.  


### 이진화 분석
이미지 밀도를 두 그룹으로 나누는 기법으로 명암 영상에서 할 수 있는 가장 기본적인 처리라고 할 수 있다.  
이진화할 임계값을 `0~255`사이로 지정하게 되면 두 그룹으로 나뉘게 되고 이러한 이진화를 한 이미지를 통해 분석했다.  

임계값을 `255`, `250`, `245`, `240`, `200`, `100`로 적용하고 분석한 결과, 이미지에는 배경 부분이 존재한다는 사실을 알 수 있었다.  
<b>이러한 배경을 제거하기 위해서 이진화 알고리즘과 침식과 팽창을 이용하여 입력 이미지를 처리해줬다.</b>  
(여러 시행을 통해 얻은 임계값은 `240`이며 노이즈를 제거하기 위해 침식 연산과 팽창 연산을 차례로 5번 적용해주었다.)  

<br><br>

### 히스토그램 분석
이미지들의 히스토그램을 분석한 결과 `0~255` 범위의 값이 골고루 쓰이지 않고 있다는 사실을 알 수 있었다.  
따라서, 이러한 값들을 더 잘 활용할 수 있도록 스트레칭이나 히스토그램 평활화 알고리즘에 대해 살펴보았다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/ea35d27b-ca7e-47ee-970a-8eb677811bce)

<br>

#### 스트레칭
스트레칭을 하게 되면 기존의 분포 모양을 유지하며 픽셀의 범위를 넓게 사용할 수 있다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/cca4e261-db86-4010-b77f-62e5313602fa)


<br>


#### 히스토그램 평활화
히스토그램 평활화는 픽셀의 범위를 넓게 사용할 수 있으나 분포 모양이 크게 변하게 된다.  
![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/a1e49038-3ce3-467d-837e-10cd44d8f903)


<br>

#### 결론
스트레칭과 히스토그램 평활화 모두 픽셀의 범위를 늘려주는 것은 동일하다.  
하지만, 히스토그램 평활화 같은 경우에는 기존 히스토그램 분포의 모양이 크게 변하므로 정보 손실이 크다.  
(즉, 여러 픽셀의 값이 하나의 값으로 합쳐지거나 픽셀 간의 변환 폭이 달라서 적용하기에 적합하지 않다.)  

따라서, 이미지 결함 시각화 알고리즘을 적용할 이미지는 아래의 4번 과정까지 마친 결과 이미지를 사용한다.  
1. 이진화의 임계값을 240으로 하여 배경과 물체의 영역을 분리  
2. 침식 5번과 팽창 5번을 하여 남아 있는 노이즈를 제거  
3. 이렇게 했을 때 남아 있는 부분만 농산물 이미지에서 사용 <br>
(즉, 이진화한 맵과 농산물 이미지 맵을 and 연산하여 농산물 이미지에서 노이즈를 제거한다는 의미)  
4. 3의 결과 이미지에서 사용할 픽셀들을 대상으로 스트레칭  


<br><br><br>



# 이미지 결함 시각화 알고리즘

이미지 결함을 시각화하기 위해서는 결함의 특징을 파악하고 그에 맞게끔 이미지를 처리해야 한다.  

<br>

### 이진화 알고리즘 이용
이미지에서 결함의 가장 큰 특징은 다른 부분에 비해서 밀도가 낮다는 특징이 있다.  
(정확히 말하면, 주변에 비해서 밀도가 낮다는 의미이다)  
따라서, 특정 임계값을 기준으로 이진화 알고리즘을 적용하여 밀도가 높은 부분과 낮은 부분으로 나누었다.  
또한, 같은 부분이라 해도 픽셀의 값에 따라 색의 농도를 다르게 하여 더 잘 파악할 수 있도록 시각화했다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/d5b01487-d95a-441c-92a2-e40c5862f672)

이러한 이미지는 사람이 보기에는 다소 가치 있는 정보를 제공하지만, 검출 알고리즘을 적용하기에는 정보가 다소 부족하다.  
모든 농산물에 대해 여러 임계값(`0`, `10`, `20`, ..., `240`, `250`)을 적용해 보았으며 이는 주피터 노트북 파일을 참조하기 바란다.  


<br><br>

### 지역 정보 이용
이미지에서 결함의 특징을 단순히 밀도가 낮다고 치부하는 것은 농산물 이미지의 형태를 전혀 고려하지 못한 방법이다.  

이미지의 결함의 더욱 구체적인 특징은 주변 영역에 비해서 밀도가 낮다는 특징이 있다.  
여기서는 현재 픽셀의 색을 결정할 때(색은 해당 픽셀이 결함일 가능성을 의미) 주변 픽셀의 정보를 이용하여 시각화했다.  

여기서 사용한 알고리즘의 원리는 아래와 같다.  
- 어떤 픽셀의 색을 결정할 때 `5 x 5` 의 평균적인 밀도와 `40 x 40` 의 평균적인 밀도를 구한다.  
- 두 값을 비교하여 `5 x 5` 부분의 밀도가 더 낮으면 빨간색, 그렇지 않으면 파란색으로 시각화했다.  
(실제로 구현에 있어서는 `40 x 40` 박스의 표준편차에 따라서 가중치를 주어 결함이 더 잘 검출되게 하였다)  


![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/a6aeea84-4b0d-458f-a452-f7a161e08bea)


시각화한 이미지를 보면, 이진화 알고리즘을 이용한 시각화보다 결함 부분을 더 잘 분리한 것을 확인할 수 있다.  


<br><br>



### 지역 정보 이용 + 영역의 경계 정보 이용
지역 정보 이용 부분의 알고리즘에서 결함 부분이 검출은 되나, 결함 부분의 검출 정도가 다소 부족한 부분이 있다.  
따라서, 해당 영역을 좀 더 정확하게 감지하여 시각화할 수 있는 방법을 찾아야 했다.  

결함 부분을 더 정확하게 감지하여 시각화하는 방법으로 각  픽셀에 대해 아래와 같은 방법으로 가중치를 구했다.  
그리고, 기존 지역 정보 이용으로 나온 정보에 여기서 구한 가중치를 더해주었다.  
- 해당 픽셀을 오른쪽 끝으로 하여 `10 x 10` 박스를 지정한다. (박스A)  
- 해당 픽셀을 왼쪽 끝으로 하여 `10 x 10` 박스를 지정한다. (박스B)  
- 해당 픽셀을 가운데로 하여 `3 x 3` 박스를 지정한다. (박스C)  
- `박스C과 박스A의 유사도`와 `박스C와 박스 B의 유사도`를 비교하여 박스C와 더 비슷한 박스를 구한다. <br>
(유사도는 해당 박스를 구성하는 픽셀의 평균값에 대한 차이가 작아야 커진다)  
- 더 유사한 박스와 그렇지 않은 박스의 차이를 계산하여 해당 픽셀에 가중치로 더해준다.  

위의 과정은 가로 방향에 해당하는 과정으로, 세로 방향에 대한 처리도 비슷하게 처리하여 가중치를 더해준다.  


자세한 설명은 아래의 예시를 참조하기 바란다.  
<details>
<summary>예시</summary>
  
![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/120b4515-29b8-4132-9b8f-b0c16ea63446)

> 예를 들어 위와 같은 경우에 박스 C와 A의 유사독 C와 B의 유사도 보다 크다.  
> 따라서, 픽셀 α의 가중치는 <b>박스 A에서 박스 B를 뺀 값</b>을 이용하여 더해준다.  
> (실제로는 영역의 표준편차 정보도 이용하여 계산한다)  
> 이렇게 하게 되면 픽셀 α는 영역의 경계 근처에 있음에도 박스 A와 같은 영역으로 판단하여 색을 입힐 수 있게 된다.   
> 
> 위의 지역 정보 이용 알고리즘을 했을 때의 박스 넓이는 1600(= 40 x 40)이며 여기에서의 박스의 넓이는 100(= 10 x 10)이다.  
> 따라서, 영역의 경계 정보 이용 알고리즘의 가중치는 지역 정보 이용 알고리즘과의 조화를 위해 마지막에 16으로 나누어서 더해준다.  
> 
> 
           
</details>


<br><br>

아래는 위에서 설명한 알고리즘을 적용한 결과에 해당하는 이미지이다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/03ef60c9-7243-45bb-842a-5f7f2db42e3c)


<br><br><br>


# 결함 검출 알고리즘

이미지 결함 시각화 알고리즘에서 결함에 해당하는 픽셀을 빨간색에 가깝게 정의(시각화)하였다.  
즉, 결함 픽셀은 (R, G, B)의 값 중에서 R은 크고 G와 B는 작은 특징을 가진다는 것이다.  
따라서, R이 0.9보다 크고, G가 0.8보다 작은 픽셀을 결함 픽셀로 정의하고 진행하였다.  
(R, G, B를 정규화해서 계산하였으므로 각 채널의 범위는 `0~1`의 값을 가진다)  

<br>

### 격자 단위 결함 추출 알고리즘
격자 단위로 이미지를 나눈 후에 격자 단위로 결함 박스를 검출하는 방법이다.  
- 이미지를 `20 x 20` 크기의 격자로 나눈 후에 격자 안에 결함에 해당하는 픽셀의 개수를 센다.  
- 박스 안의 픽셀의 개수가 임계값을 넘으면 해당 박스를 결함 박스로 검출한다.  


![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/cc57f7c0-dea9-4d9f-b10f-eb9722b8f9a0)

(이해를 돕기 위해서 모든 격자를 나타낸 것이고, 실제로는 초록 박스 하나만 보여진다)  

<br><br>

### 결함 집합 추출
이미지에서 모여 있는 결함 픽셀들을 한 그룹으로 묶어 우선순위가 높은 집합을 결함으로 검출하는 방법이다.  
- 결함 픽셀에 해당하는 픽셀을 모두 찾는다.  
- dfs 알고리즘을 이용하여 연결되어 있는 결함 픽셀들을 한 그룹으로 묶는다.  
- 찾은 그룹에서 우선순위가 가장 높은 그룹을 결함이 임계값을 넘는지 확인한다.  <br>
(실제 코드에서는 우선순위를 그룹에 포함되어 있는 결함 픽셀 수로 처리하였다)
- 만약에 해당 그룹이 임계값을 넘으면 결함을 검출하고 그렇지 않으면 결함을 검출하지 않는다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/a06788a5-d94c-4ba9-8a3c-c996bc95f915)


<br>

자세한 설명은 아래의 예시를 참조하기 바란다.  
<details>
<summary>예시</summary>

 ![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/d02fcd3c-34fa-41af-a6a4-a629b0032470)


> 위의 그림에서 하나의 결함 그룹은 `[y_min, x_min, y_max, x_max, num]` 의 형태로 표현된다.  
> - 처음 4개의 인자는 해당 그룹을 나타내는 박스의 왼쪽 상단 좌표와 오른쪽 하단 좌표를 의미한다.  
> - `num`은 해당 결함 그룹의 결함 픽셀 개수를 담고 있다.  
> 
> 위의 그림에서 왼쪽에 해당하는 이미지에서 초록색 박스는 결함 그룹이며 결함으로 검출된 그룹을 의미한다.  
> 노란색 박스는 결함 그룹이지만 우선순위가 밀려나 최종적으로 결함으로 선택되지 못한 그룹을 의미한다.  
> 
> 위의 그림에서 오른쪽 리스트는 모든 결함 그룹의 정보를 표시한 것이다.  
> 이해를 돕기 위해 편의상 그림에는 그러한 그룹을 2개만 시각화 하였다.  

           
</details>










