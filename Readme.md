# 프로젝트 소개

### 프로젝트 소개

본 프로젝트는 농산물 x-ray 이미지에서 결함을 검출할 수 있도록 시각화하는 프로젝트이다.  


![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/702b7a39-e77e-4a33-aea6-024a07769112)


<br><br>


### 프로젝트 배경
실제 농산물을 재배하는 환경에서 컨베이어 벨트 위의 농산물들의 결함을 실시간으로 검출할 수 있도록 도와준다.  


![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/c265a7d6-939f-44be-9528-8663468df7f3)


<br><br>


### 프로젝트 설계
본 프로젝트는 GUI 형태의 프로그램을 제공하며 아래와 같이 동작한다.  
- <b>Open 버튼</b>을 누르면 파일 탐색기가 열리며 이미지 파일을 여러 개 선택할 수 있다.  
- 이미지 파일을 선택하고 <b>detect 버튼</b>을 누르면 오른쪽에 결함 검출 알고리즘을 적용한 이미지가 나타난다.  
- 화면 아래의 인디케이터에 현재 몇 번째 이미지를 보고 있는지가 뜨며 (키보드) `A`키와 `D`키로 페이지를 이동할 수 있다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/67e7575b-f30f-49ae-b1c0-4f7815bd4aa6)



<br><br><br>

# 이미지 데이터 설명
농산물은 총 6가지 존재하고, 정상과 비정상으로 구별할 수 있으므로 모든 데이터는 12가지로 카테고리화할 수 있다.  
( 농산물 = {`바나나`, `당근`, `양파`, `귤`, `피망`, `고구마`} )  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/953d5762-7a15-4258-94b0-3ce6213d3ab7)

<br><br>

농산물 데이터의 이미지 크기는 `800 x 1024`, `400 x 1024` 두 가지 형태만 존재한다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/0c4122c4-9521-46b7-8055-8c83303c0934)

<br><br>

x-ray 이미지 데이터는 명암 영상으로 각 픽셀은 `0~255` 값을 가지며 밀도가 높을수록(검은색에 가까울수록) 픽셀 값이 작다.  

<br><br><br>


# 결함에 대한 정의
본 프로젝트에서 결함이란 `벌레가 파먹은 부분`, `썩은 부분`, `과일의 긁힌 자국` 등으로 정의한다.  
이러한 결함은 눈으로 봤을 때 x-ray 이미지 상에서 밀도가 낮게 보이는 특징이 있다.  

<br><br><br>

# 이미지 분석
이미지에서 찾을 수 있는 결함의 가장 큰 특징은 밀도가 다른 부분에 비해서 낮다는 특징이다.  
따라서, 밀도가 낮은 부분을 어떻게 하면 극대화할 수 있을까에 초점을 맞추며 이미지 분석을 진행했다.  


### 이진화 분석
이미지 밀도를 두 그룹으로 나누는 기법으로 명암 영상에서 할 수 있는 가장 기본적인 처리라고 할 수 있다.  
이진화할 임계값을 `0~255`사이로 지정하게 되면 두 그룹으로 나뉘게 되고 이러한 이진화를 한 이미지를 통해 분석했다.  

임계값을 `255`, `250`, `245`, `240`, `200`, `100`로 적용하고 분석한 결과, 이미지에는 배경 부분이 존재한다는 사실을 알 수 있었다.  
<b>이러한 배경을 제거하기 위해서 이진화 알고리즘과 침식과 팽창을 이용하여 입력 이미지를 처리해줬다.</b>  
(여러 시행을 통해 얻은 임계값은 `240`이며 노이즈를 제거하기 위해 침식 연산과 팽창 연산을 차례로 5번 적용해주었다.)  

<br><br>

### 히스토그램 분석
이미지들의 히스토그램을 분석한 결과 `0~255` 범위의 값이 골고루 쓰이지 않고 있다는 사실을 알 수 있었다.  
따라서, 이러한 값들을 더 잘 활용할 수 있도록 스트레칭이나 히스토그램 평활화 알고리즘에 대해 살펴보았다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/ea35d27b-ca7e-47ee-970a-8eb677811bce)

<br>

#### 스트레칭
스트레칭을 하게 되면 기존의 분포 모양을 유지하며 픽셀의 범위를 넓게 사용할 수 있다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/cca4e261-db86-4010-b77f-62e5313602fa)


<br>


#### 히스토그램 평활화
히스토그램 평활화는 픽셀의 범위를 넓게 사용할 수 있으나 분포 모양이 크게 변하게 된다.
![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/a1e49038-3ce3-467d-837e-10cd44d8f903)


<br>

#### 결론
스트레칭과 히스토그램 평활화 모두 픽셀의 범위를 늘려주는 것은 동일하다.  
하지만, 히스토그램 평활화 같은 경우에는 기존 히스토그램 분포의 모양이 크게 변하므로 정보 손실이 크다.  
(즉, 여러 픽셀의 값이 하나의 값으로 합쳐지거나 픽셀 간의 변환 폭이 달라서 적용하기에 적합하지 않다.)  

따라서, 이미지 결함 시각화 알고리즘을 적용할 이미지는 아래의 4번 과정까지 마친 결과 이미지를 사용한다.
1. 이진화의 임계값을 240으로 하여 배경과 물체의 영역을 분리  
2. 침식 5번과 팽창 5번을 하여 남아 있는 노이즈를 제거  
3. 이렇게 했을 때 남아 있는 부분만 농산물 이미지에서 사용 <br>
(즉, 이진화한 맵과 농산물 이미지 맵을 and 연산하여 농산물 이미지에서 노이즈를 제거한다는 의미)
4. 3의 결과 이미지에서 사용할 픽셀들을 대상으로 스트레칭


<br><br><br>



# 이미지 결함 시각화 알고리즘

이미지 결함을 시각화하기 위해서는 결함의 특징을 파악하고 그에 맞게끔 이미지를 처리해야 한다.  

<br>

### 이진화 알고리즘 이용

이미지에서 결함의 가장 큰 특징은 다른 부분에 비해서 밀도가 낮다는 특징이 있다.  
(정확히 말하면, 주변에 비해서 밀도가 낮다는 의미이다)  
따라서, 특정 임계값을 기준으로 이진화 알고리즘을 적용하여 밀도가 높은 부분과 낮은 부분으로 나누었다.  
또한, 같은 부분이라 해도 픽셀의 값에 따라 색의 농도를 다르게 하여 더 잘 파악할 수 있도록 시각화했다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/d5b01487-d95a-441c-92a2-e40c5862f672)

이러한 이미지는 사람이 보기에는 다소 가치 있는 정보를 제공하지만, 검출 알고리즘을 적용하기에는 정보가 다소 부족하다.  
모든 농산물에 대해 여러 임계값(`0`, `10`, `20`, ..., `240`, `250`)을 적용해 보았으며 이는 주피터 노트북 파일을 참조하기 바란다.


<br><br>

### 지역 정보 이용
이미지에서 결함의 특징을 단순히 밀도가 낮다고 치부하는 것은 농산물 이미지의 형태를 전혀 고려하지 못한 방법이다.  

이미지의 결함의 더욱 구체적인 특징은 주변 영역에 비해서 밀도가 낮다는 특징이 있다.  
여기서는 현재 픽셀의 색을 결정할 때(색은 해당 픽셀이 결함일 가능성을 의미) 주변 픽셀의 정보를 이용하여 시각화했다.

여기서 사용한 알고리즘의 원리는 아래와 같다.  
- 어떤 픽셀의 색을 결정할 때 `5 x 5` 의 평균적인 밀도와 `40 x 40` 의 평균적인 밀도를 구한다.  
- 두 값을 비교하여 `5 x 5` 부분의 밀도가 더 낮으면 빨간색, 그렇지 않으면 파란색으로 시각화했다.  

(실제로 구현에 있어서는 `40 x 40` 박스의 표준편차에 따라서 가중치를 주어 결함이 더 잘 검출되게 하였다)  

자세한 설명은 아래의 예시를 참조하기 바란다.  

<details>
<summary>예시</summary>
 
![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/9d6d45be-a43f-4303-ad2a-06dc62bf8e97)

> 픽셀 α의 색을 결정할 때 해당 픽셀을 중심으로 하는 `40 x 40` 영역의 정보와 `5 x 5` 영역의 정보를 이용한다.  
> `5 x 5` 영역의 평균에서 `40 x 40` 영역의 평균을 뺀 값을 `40 x 40` 영역의 표준편차로 나눈 값 $z$를 구한다.  
> $z$가 의미하는 값은 해당 픽셀과 아주 가까운 영역이 근처 영역에 비해 얼마나 밀도가 낮은지를 나타낸다.  
> 표준편차로 나누는 이유는 영역이 균일한지를 확인하여 균일한데 차이가 많이 나면 더 높은 값을 주기 위해서이다.  
         

</details>

<br><br>


![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/a6aeea84-4b0d-458f-a452-f7a161e08bea)


시각화한 이미지를 보면, 이진화 알고리즘을 이용한 시각화보다 결함 부분을 더 잘 분리한 것을 확인할 수 있다.  


<br><br>



### 지역 정보 이용 + 영역의 경계 정보 이용
지역 정보 이용 부분의 알고리즘에서 결함 부분이 검출은 되나, 결함 부분의 검출 정도가 다소 부족한 부분이 있다.  
따라서, 해당 영역을 좀 더 정확하게 감지하여 시각화할 수 있는 방법을 찾아야 했다.  

결함 부분을 더 정확하게 감지하여 시각화하는 방법으로 각  픽셀에 대해 아래와 같은 방법으로 가중치를 구했다.  
그리고, 기존 지역 정보 이용으로 나온 정보에 여기서 구한 가중치를 더해주었다.  
- 해당 픽셀을 오른쪽 끝으로 하여 `10 x 10` 박스를 지정한다. (박스A)
- 해당 픽셀을 왼쪽 끝으로 하여 `10 x 10` 박스를 지정한다. (박스B)
- 해당 픽셀을 가운데로 하여 `3 x 3` 박스를 지정한다. (박스C)
- `박스C와 박스A의 유사도`와 `박스C와 박스 B의 유사도`를 비교하여 박스C와 더 비슷한 박스를 구한다. <br>
(유사도는 해당 박스를 구성하는 픽셀의 평균값에 대한 차이가 작아야 커진다)
- 더 유사한 박스와 그렇지 않은 박스의 차이를 계산하여 해당 픽셀에 가중치로 더해준다.

위의 과정은 가로 방향에 해당하는 과정으로, 세로 방향에 대한 처리도 비슷하게 처리하여 가중치를 더해준다.  


자세한 설명은 아래의 예시를 참조하기 바란다.  
<details>
<summary>예시</summary>
  
![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/120b4515-29b8-4132-9b8f-b0c16ea63446)

> 예를 들어 위와 같은 경우에 박스 C와 A의 유사도 C와 B의 유사도 보다 크다.  
> 따라서, 픽셀 α의 가중치는 <b>박스 A에서 박스 B를 뺀 값</b>을 이용하여 더해준다.  
> (실제로는 영역의 표준편차 정보도 이용하여 계산한다)  
> 이렇게 하게 되면 픽셀 α는 영역의 경계 근처에 있음에도 박스 A와 같은 영역으로 판단하여 색을 입힐 수 있게 된다.  
> 
> 위의 지역 정보 이용 알고리즘을 했을 때의 박스 넓이는 1600(= 40 x 40)이며 여기에서의 박스의 넓이는 100(= 10 x 10)이다.  
> 따라서, 영역의 경계 정보 이용 알고리즘의 가중치는 지역 정보 이용 알고리즘과의 조화를 위해 마지막에 16으로 나누어서 더해준다.  
> 
           
</details>


<br><br>

아래는 위에서 설명한 알고리즘을 적용한 결과에 해당하는 이미지이다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/03ef60c9-7243-45bb-842a-5f7f2db42e3c)


<br><br><br>


# 결함 검출 알고리즘

이미지 결함 시각화 알고리즘에서 결함에 해당하는 픽셀을 빨간색에 가깝게 정의(시각화)하였다.  
즉, 결함 픽셀은 (R, G, B)의 값 중에서 R은 크고 G와 B는 작은 특징을 가진다는 것이다.  
따라서, R이 0.9보다 크고, G가 0.8보다 작은 픽셀을 결함 픽셀로 정의하고 진행하였다.  
(R, G, B를 정규화해서 계산하였으므로 각 채널의 범위는 `0~1`의 값을 가진다)  

<br>

### 격자 단위 결함 추출 알고리즘
격자 단위로 이미지를 나눈 후에 격자 단위로 결함 박스를 검출하는 방법이다.  
- 이미지를 `20 x 20` 크기의 격자로 나눈 후에 격자 안에 결함에 해당하는 픽셀의 개수를 센다.  
- 박스 안의 픽셀의 개수가 임계값을 넘으면 해당 박스를 결함 박스로 검출한다.  


![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/cc57f7c0-dea9-4d9f-b10f-eb9722b8f9a0)

(이해를 돕기 위해서 모든 격자를 나타낸 것이고, 실제로는 초록 박스 하나만 보여진다)  

이 알고리즘의 단점은 아래와 같이 결함들이 걸친 상황에서 결함을 제대로 검출하지 못한다는 점이 있다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/2d3b408e-f564-44fd-9a1f-518faca9b3ce)



<br><br>

### 결함 집합 추출
위의 격자 단위 결함 추출 알고리즘은 결함 픽셀을 기준으로 하는 것이 아닌 박스를 기준으로 검출한다는 단점이 있다.  

이미지에서 모여 있는 결함 픽셀들을 한 그룹으로 묶어 우선순위가 높은 집합을 결함으로 검출하는 방법이다.  
- 결함 픽셀에 해당하는 픽셀을 모두 찾는다.  
- dfs 알고리즘을 이용하여 연결되어 있는 결함 픽셀들을 한 그룹으로 묶는다.  
- 찾은 그룹에서 우선순위가 가장 높은 그룹을 결함이 임계값을 넘는지 확인한다.  <br>
(실제 코드에서는 우선순위를 그룹에 포함되어 있는 결함 픽셀 수로 처리하였다)
- 만약에 해당 그룹이 임계값을 넘으면 결함을 검출하고 그렇지 않으면 결함을 검출하지 않는다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/a06788a5-d94c-4ba9-8a3c-c996bc95f915)


<br>

자세한 설명은 아래의 예시를 참조하기 바란다.
<details>
<summary>예시</summary>

 ![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/d02fcd3c-34fa-41af-a6a4-a629b0032470)


> 위의 그림에서 하나의 결함 그룹은 `[y_min, x_min, y_max, x_max, num]` 의 형태로 표현된다.
> - 처음 4개의 인자는 해당 그룹을 나타내는 박스의 왼쪽 상단 좌표와 오른쪽 하단 좌표를 의미한다.
> - `num`은 해당 결함 그룹의 결함 픽셀 개수를 담고 있다.
> 
> 위의 그림에서 왼쪽에 해당하는 이미지에서 초록색 박스는 결함 그룹이며 결함으로 검출된 그룹을 의미한다.  
> 노란색 박스는 결함 그룹이지만 우선순위가 밀려나 최종적으로 결함으로 선택되지 못한 그룹을 의미한다.  
> 
> 위의 그림에서 오른쪽 리스트는 모든 결함 그룹의 정보를 표시한 것이다.  
> 이해를 돕기 위해 편의상 그림에는 그러한 그룹을 2개만 시각화 하였다.  

           
</details>

<br><br><br>


# 기타 사항

### 농산물의 경계 부분 제거
농산물의 경계 부근에서 상대적으로 밀도가 낮은 특징이 있어 결함으로 인식하는 경우가 발생했다.  
이를 아래와 같은 방법을 이용해서 해결했다.  
- 침식 연산 5번, 팽창 연산 5번한 이진화 이미지를 생성 (bimap1)   
- 침식 연산 5번, 팽창 연산 2번한 이진화 이미지를 생성 (bimap2)  
- bimap1을 기준으로 이미지 정보를 생성하고, bimap2를 기준으로 이미지 결함 시각화 알고리즘 적용  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/5ae42b49-865b-4a24-9a09-b6ab6e5ffe4e)



<br>



### 농산물에 따른 처리
농산물마다 특징이 달라 아래와 같은 부분을 따로 처리해주었다.  
- 오렌지와 양파는 가운데의 밀도가 낮은 특징이 있어 이 부분을 처리해주었다.  
	 - 오렌지와 양파의 경우 중심 좌표를 계산하여 이를 중심으로 적절한 크기의 원을 결함 검출 부분에서 제거해주었다.  

- 농산물 별로 밀포 분포가 달라서 각각 적절한 임계값을 적용해주었다.  
	- 농산물에 따라서 밀포의 분포가 다르기 때문에 그러한 분포에 맞는 적절한 임계값을 사용해주었다.  

![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/e6167a23-dfb4-478c-8d28-f09cb0e5c946)

> thresholds1은 결함 검출할 픽셀과 관련이 있으며, 높을 수록 결함 픽셀이 검출이 잘 안 된다.  
> thresholds2은 해당 이미지의 중심에서 제거할 원의 반지름을 설정한다.  
> thresholds3는 영역 경계 정보 알고리즘의 가중치를 얼마나 적용시킬 건지를 나타낸다.  값이 클수록 적용시키는 정도가 작아진다.  
(16.0으로 하면 나온 가중치를 16.0으로 나누어 적용한다는 의미이다.)


<br>


### 농산물 결함 시각화 알고리즘(지역 정보 이용) 최적화
결함 시각화 과정 중 지역 정보 이용을 하는 알고리즘은 한 픽셀에 아래와 같은 과정을 수행한다.
- 해당 픽셀을 중심으로 `5 x 5` 크기의 평균을 구한다.
- 해당 픽셀을 중심으로 `40 x 40` 크기의 평균과 표준편차를 구한다.

이러한 연산을 한 픽셀당 약 1700번의 연산을 하게 되며 이미지 크기는 `800 x 1024` 이다.  
따라서, 총 연산은 `1700 x 800 x 1024` 번의 연산을 하게 되며 이는 약 14억 정도의 연산이 걸리게 된다.

이러한 연산을 2차원 누적합과 2차원 제곱 누적합을 이용하여 한 픽셀당 수행하는 연산 횟수를 $O(1)$로 만들었다.  
즉, 2차원 누적 배열을 만드는 `2 x 800 x 1024`를 수행하면 알고리즘의 연산 횟수를 `1 x 800 x 1024` 만에 수행할 수 있다.  
따라서, 배열 내의 여러 연산까지 고려해도 약 1000만 정도의 연산으로 알고리즘 수행이 가능하다.  


<br>


### 속도 부분에서의 이슈
알고리즘을 최적화 했음에도 불구하고 큰 배열의 여러 부분을 접근하는 과정에서 파이썬은 큰 시간이 소요되었다.    
따라서, 함수 단위로 작성하면 해당 함수를 기계 코드로 변환하여 실행하게 해주는 <b>numba 라이브러리</b>를 이용하였다.    
numba 라이브러리를 사용하면 처음 한 번의 컴파일 이후에는 약 100-1000배 빠르게 함수를 재사용할 수 있다.  
(본 프로젝트에서는 약 200-300배 빨라짐을 확인할 수 있었다)  

이러한 라이브러리를 사용하려면 함수 단위로 작성해야 하며 다른 라이브러리와의 호환이 안 되었다.  
이러한 점을 고려하여 형식에 맞춰 함수 단위로 프로그래밍 하여 본 프로젝트를 진행하였다.  

한 가지 아쉬운 점은 numba 라이브러리에서 제공하는 캐쉬 기능을 사용하지 못했다는 것이다.  
캐쉬 기능은 프로그램을 맨 처음에 실행했을 때 컴파일한 결과를 캐쉬로 만들어 파일 형태로 저장하는 기능이다.  
이렇게 하면 프로그램을 다음에 실행해도 이 캐쉬에 있는 값을 가져와 함수를 실행하기 때문에 매우 빠르다.  
이러한 기능을 사용하려면 numba 라이브러리를 사용하는 함수에서 동적할당을 아예 배제해야 하는데 그 부분까지는 수행하지 못했다.  

현재는 프로그램을 실행 처음에 약 200초 정도의 시간이 걸리며, 이후에는 이미지 당 1초 내로 처리가 가능한 상태이다.  


<br><br><br>



# 코드 구조 간략화


![image](https://github.com/tjdans6342/Defect_Detection_Algorithm/assets/70836243/1e88e588-3891-41ab-9011-70ff4ec57e13)


`defect_detection(img, th1, th2, th3)`  
- img를 넣으면 결함을 검출한 이미지를 반환하는 함수이다.  

`cal_center(img)`  
- img를 넣으면 해당 이미지에 있는 농산물의 중심 좌표를 (y, x) 형태로 반환한다.  

`get_defect_candidates(img)`  
- 이미지 결함 시각화 알고리즘을 적용한 img와 결함 픽셀을 정의하는 임계값 th4, th5이 입력으로 들어간다.  
- 결함 후보에 대한 정보들을 담은 리스트를 반환한다.  
- 결함 후보에 대한 정보는 `[y_min, x_min, y_max, x_max, num]` 형태이며 박스와 결함 픽셀 수를 담고 있다.  



